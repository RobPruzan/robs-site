import { InfiniteCanvasMouseZooming } from "./InfiniteCanvasMouseZooming";
import { InfiniteCanvas } from "./InfiniteCanvas";
import { InfiniteCanvasWSBefore } from "./InfiniteCanvasWSBefore";
import { InfiniteCanvasMouseZoomingRefined } from "./InfiniteCanvasMouseZoomingRefined";
import { WithCodeTab, FileCodeEditor } from "../../../../lib/WithCodeTab";
import { SimpleCanvas } from "./SimpleCanvas";
import { SimpleCanvasPan } from "./SimpleCanvasPan";
import { SimpleCanvasMultiplayer } from "./SimpleCanvasMultiplayer";
import { SimpleCanvasMultiplayerDerived } from "./SimpleCanvasMultiplayerDerived";
import { SimpleCanvasDerived } from "./SimpleCanvasDerived";
import { SimpleCanvasZoom } from "./SimpleCanvasZoom";

import { InfiniteCanvasWSCoordinator } from "./InfiniteCanvasWSCoordinator";

import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import Link from "next/link";

6/30/24

## Motivation

I'm now building my third app which needs an infinite canvas- pannable and zoomable. I like implementing it myself over using an abstraction
to avoid all of the bloat that comes with graphics libaries. You can get pretty far with not a lot of canvas code.

Id like to document:

- How my implementation of an infinite canvas has changed
- Jow I'd currently implement an infinite canvas,
- How to integrate multiplayer into an infinite canvas.

## Pre-reqs/ dependencies

- React
- Typescript

As long as you understand the basic fundamentals of React & Typescript, the code snippets should make sense to you.

## Introduction

The first time I built an infinite canvas was for my algorithm visualization website <Link href="https://algoviz.app">AlgoViz</Link>.
This was also the first time I built anything canvas related, so I think it's useful to point out naive solutions that someone
might think of, and how they compare to a more refined solution.

### Rendering geometry

The thing all infinite canvas applications will have in common is the need to render some geometry on the canvas.

<WithCodeTab filePath="./app/blog/(articles)/infinite-canvas/SimpleCanvas.tsx">
  <SimpleCanvas />
</WithCodeTab>

This is a simple task since the browser gives us all the API's we need to draw different geometry to the canvas.
Our responsibility is to handle its movement.

### Panning

When I first implemented panning my goal was simply to move the geomotry on the screen with my trackpad.
So the most straight forward solution (to me) was updating the location of my geometry in state.

To implement this, all thats needed ontop of the prior example is to:

1. Listen for trackpad events on the canvas (`"wheel"`)
2. Update the geomotry state by how much movement was detected during the wheel event (`event.deltaX, event.deltaY`)

<WithCodeTab filePath="./app/blog/(articles)/infinite-canvas/SimpleCanvasPan.tsx">
  <SimpleCanvasPan />
</WithCodeTab>

This gets the job done if all we want is the allusion of panning.

But, this implementation quickly falls apart if we start thinking about using the canvas implementation in a multiplayer setting.
By multiplayer, I mean the canvas geometry state is shared between users.

<WithCodeTab filePath="./app/blog/(articles)/infinite-canvas/SimpleCanvasMultiplayer.tsx">
  <SimpleCanvasMultiplayer />
</WithCodeTab>

> **Note** Here I simulated multiple players and shared state with a react component that passes down state to
> 2 canvas instances. In reality you would be using something like a web-socket connection to dispatch
> state updates to other players.

What the above components show you is that panning one canvas instance also pans the other. Currently our local coordinate system
is tightly coupled to the geometry we want to render.

Instead of modifying the actual position of the geometry to implement panning, we can just maintain state that holds how far we are translated
in the x and y direction. After we can apply that translation when we draw to the canvas.

<WithCodeTab filePath="./app/blog/(articles)/infinite-canvas/SimpleCanvasDerived.tsx">
  <SimpleCanvasMultiplayerDerived />
</WithCodeTab>

Now panning one canvas will succesfully not affect the other user's geometry state.

### Zooming

Zooming is a similar concept to panning, but instead of adding to our coordinates by some amount, we will scale.

We can do this in 2 ways:

- Update the geomotery's coordinates everytime the user zooms
- Maintain state representing how much the user is zoomed, where we apply the transformation to the geometry when drawing to canvas

Because we already encountered the pitfalls of updating the actual geomotery's coordinates, we will jump
straight to maintaining a seperate piece of state that represents how much the user is zoomed.

```ts
const [zoom, setZoom] = useState(1);
```

To do this, we will re-use the wheel event we setup on the canvas- the browser exposes zooming through
a wheel event, where the `event.ctrlKey == true`. We can then read the `event.deltaY` property to know how much
the user is zooming in either direction. We can continously update our zoom value everytime we recieve this event.

Once we have our tracked zoom value, we can apply the zoom on the `(x, y, radius)` of the circle before drawing it to the canvas:

<WithCodeTab filePath="./app/blog/(articles)/infinite-canvas/SimpleCanvasZoom.tsx">
  <SimpleCanvasZoom />
</WithCodeTab>

This works, but we have some annoying behavior, it always zooms to the origin.

This makes sense when you think about it-
0 \* \<anything> is 0, and that will never change. So when we zoom, everything at the origin will not move from our perspective, while
everything not at the origin will be scaled to a coordinate that is further away from `(0,0)`. Giving the
appearence that the zoom is fixed around the origin, and everything else is moving away.

The desirable behavior here would be to lock screen around the mouse, not `(0,0)`. So that when a user zooms, the geometry
at the users mouse position will grow in size, rather than move away. Otherwise the user would have to zoom, then translate
back to the place they to go, zoom, translate, zoom...

Instead of the user performing this uncomfortable set of actions, we could do this for them. Everytime the user zooms,
dont allow the mouse to gravitate towards the origin (0,0) by translating the screen the **opposite** amount it wants to move.

To do this, we would need to know where our mouse is in our coordinate system (which I will refer to as world
coordinates), while the browser can only give us information about where our mouse is relative to the screen (which I will refer to as screen
coordinates). We need the world coordinate because our mouse will not be moving relative to the screen.

So lets make a function that converts screen coordinate's to world coordinates

```ts
const toWorld = ({
  translation,
  zoom,
  screenCoordinate,
}: {
  translation: { x: number; y: number };
  zoom: number;
  screenCoordinate: { x: number; y: number };
}) => {
  return {
    // shift the coordinate by the translation amount, then scale the coordiante by the zoom factor
    x: (screenCoordinate.x - translation.x) * zoom,
    y: (screenCoordinate.y - translation.y) * zoom,
  };
};
```

Now using this we can calculate how much our mouse has moved, in world coordinates, inbetween zooms. Then we
update our translation state so that the `(x,y)` movement caused by the zoom would be counter-acted by this translation.

```ts
const mousePosition = coordinatesFromMouseEvent(event);
const priorMouseWorldPosition = toWorld({
  translation,
  zoom,
  screenCoordinate: mousePosition,
});
const newZoom = zoom * Math.pow(event.deltaY, 0.99);
const newMouseWorldPosition = toWorld({
  translation,
  zoom: newZoom,
  screenCoordinate: mousePosition,
});

setTranslation((prev) => ({
  x: prev.x + (newMouseWorldPosition.x - priorMouseWorldPosition.x),
  y: prev.y + (newMouseWorldPosition.y - priorMouseWorldPosition.y),
}));
```

<InfiniteCanvasMouseZooming />

Now that we have a working implementation, so lets clean up some things.

The canvas may be a little blury depending on your device resolution, we can make the canvas
use more pixels when rendering objects on devices with higher device pixel ratios (dpi) with:

```ts
const ctx = canvas.getContext("2d");
const dpr = window.devicePixelRatio;
const rect = canvas.getBoundingClientRect();

canvas.width = rect.width * dpr;
canvas.height = rect.height * dpr;

canvas.style.width = `${rect.width}px`;
canvas.style.height = `${rect.height}px`;

ctx.scale(dpr, dpr);
```

And we don't need to manually translate and zoom the coordinates of every object we draw, the canvas can
handle this automatically:

```ts
ctx.scale(zoom, zoom);
ctx.translate(-x, -y);
```

We can also make this implementation reusable by extracting the logic to a hook

<WithCodeTab filePath="./app/blog/(articles)/infinite-canvas/InfiniteCanvas.tsx">
  <InfiniteCanvas />
</WithCodeTab>

### Multiplayer

To make our canvas multiplayer I will use a [bun](https://bun.sh/) with no dependencies.

Lets first setup a simple websocket server for our future multiplayer canvas

```ts
const server = Bun.serve({
  fetch(req, server) {
    server.upgrade(req);
  },
  websocket: {
    open: (ws) => {
      ws.subscribe("canvas");
    },
    message: async (ws, message) => {
      ws.publish("canvas", message);
    },
  },
  port: 8080,
});

console.log(`Listening on ${server.hostname}:${server.port}`);
```

Now we can run the server with:

`bun run <filename>`

Now, lets setup some interaction on our canvas before we start recieving interactions from other players.
We will start with drawing a circle on click of the canvas.

<WithCodeTab filePath="./app/blog/(articles)/infinite-canvas/InfiniteCanvasWSBefore.tsx">
  <InfiniteCanvasWSBefore />
</WithCodeTab>

<InfiniteCanvasWSCoordinator />
